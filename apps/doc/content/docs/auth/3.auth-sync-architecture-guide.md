---
title: Authentication Sync Architecture & Design Guide
description: Architecture & Design
---

## 🏗️ System Architecture Overview

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web App       │    │   Server        │    │   Extension     │
│  (Next.js)      │    │  (Hono+Auth)    │    │   (WXT+React)   │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • Auth Client   │◄──►│ • Better Auth   │◄──►│ • Auth Client   │
│ • Sync Utility  │    │ • CORS Config   │    │ • Storage API   │
│ • Event System  │    │ • Session Mgmt  │    │ • Background    │
│ • Content Hook  │    │ • API Routes    │    │ • Content Script│
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │ Chrome Storage  │
                    │ (Persistent)    │
                    └─────────────────┘
```

## 🔄 Data Flow Architecture

### Primary Authentication Flow

```
User Action → Auth Request → Server Validation → Response → State Update → Sync Trigger
     ↓              ↓              ↓              ↓            ↓            ↓
  Login Form → Better Auth → Database Check → JWT Token → Local State → Cross-Platform
```

### Cross-Platform Sync Flow

```
Platform A (Login) → Event Dispatch → Content Script → Background Script → Storage Update → Platform B (Update)
```

## 🎯 Design Approach & Philosophy

### 1. **Event-Driven Architecture**

```typescript
// Core principle: Loose coupling through events
class AuthEventSystem {
  // Web app dispatches events
  dispatchAuthEvent(type: string, data: any) {
    window.dispatchEvent(
      new CustomEvent("auth-sync", {
        detail: { type, data },
      })
    );
  }

  // Extension listens for events
  listenForAuthEvents() {
    window.addEventListener("auth-sync", this.handleAuthEvent);
  }
}
```

**Why This Approach:**

- **Decoupled Components:** Web app and extension don't directly depend on each other
- **Scalable:** Easy to add more platforms (mobile app, desktop app)
- **Maintainable:** Changes in one platform don't break others
- **Testable:** Each component can be tested independently

### 2. **Multi-Layer Sync Strategy**

```
Layer 1: Immediate Sync (Content Script Events)     ← Real-time
Layer 2: Background Sync (Periodic Server Check)    ← Reliability
Layer 3: Storage Persistence (Chrome Storage API)   ← Offline Support
Layer 4: Manual Sync (User-Triggered)              ← Fallback
```

### 3. **State Management Pattern**

```typescript
// Centralized auth state with multiple sync sources
interface AuthState {
  user: User | null;
  session: Session | null;
  isAuthenticated: boolean;
  lastSync: Date;
  syncSource: 'server' | 'storage' | 'event';
}

// State flows through predictable pipeline
Server → Storage → Local State → UI Update
```

## 🔧 Implementation Strategy

### Phase 1: Foundation Setup

```typescript
// 1. Server Configuration
export const auth = betterAuth({
  trustedOrigins: ['web-app', 'extension'],
  // Enable cross-origin requests
});

// 2. Extension Permissions
manifest: {
  permissions: ["storage", "activeTab"],
  host_permissions: ["server-url", "web-app-url"]
}

// 3. Web App Integration
ExtensionSync.initialize(); // Start listening for extension
```

### Phase 2: Core Sync Components

```typescript
// Extension: Auth Storage Layer
class AuthStorage {
  static async save(state: AuthState) {
    await chrome.storage.local.set({ auth: state });
  }

  static async load(): Promise<AuthState | null> {
    const result = await chrome.storage.local.get("auth");
    return result.auth || null;
  }
}

// Extension: Sync Manager
class AuthSync {
  static async syncWithServer() {
    const session = await authClient.getSession();
    const state = this.buildAuthState(session);
    await AuthStorage.save(state);
    return state;
  }
}

// Web App: Extension Communication
class ExtensionSync {
  static notifyAuthChange(data: any) {
    // Multiple communication channels for reliability
    this.dispatchEvent(data); // Content script
    this.updateStorage(data); // Cross-tab sync
    this.broadcastMessage(data); // Service worker
  }
}
```

### Phase 3: Real-Time Communication

```typescript
// Content Script: Bridge between web app and extension
export default defineContentScript({
  matches: ["web-app-url/*"],
  main() {
    // Listen for web app auth events
    window.addEventListener("auth-sync", (event) => {
      chrome.runtime.sendMessage({
        type: "AUTH_EVENT",
        data: event.detail,
      });
    });

    // Inject monitoring script
    this.injectAuthMonitor();
  },
});

// Background Script: Central message hub
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  switch (message.type) {
    case "AUTH_EVENT":
      AuthSync.handleWebAppEvent(message.data);
      break;
    case "SYNC_REQUEST":
      AuthSync.syncWithServer().then(sendResponse);
      break;
  }
});
```

### Phase 4: UI Integration

```typescript
// Extension: React Hook for Auth State
export const useAuth = () => {
  const [authState, setAuthState] = useState(initialState);

  useEffect(() => {
    // Load from storage
    AuthStorage.load().then(setAuthState);

    // Listen for changes
    const cleanup = AuthStorage.onChange(setAuthState);
    return cleanup;
  }, []);

  return { ...authState, signIn, signOut, sync };
};

// Web App: Enhanced Hook with Extension Sync
export const useAuthWithSync = () => {
  const auth = useAuth();

  const signIn = async (credentials) => {
    const result = await auth.signIn(credentials);
    if (result.success) {
      ExtensionSync.notifyUserSignedIn(result.user);
    }
    return result;
  };

  return { ...auth, signIn };
};
```

## 🏆 Benefits & Advantages

### 1. **User Experience Benefits**

- **Seamless Flow:** Login once, authenticated everywhere
- **No Friction:** Users don't need to login separately
- **Consistent State:** Same user info across platforms
- **Offline Support:** Works even without internet

### 2. **Technical Benefits**

- **Scalable Architecture:** Easy to add new platforms
- **Fault Tolerant:** Multiple sync mechanisms ensure reliability
- **Performance Optimized:** Minimal server requests
- **Security Focused:** Proper token handling and CORS

### 3. **Development Benefits**

- **Modular Design:** Each component is independent
- **Easy Testing:** Clear separation of concerns
- **Maintainable:** Well-structured codebase
- **Debuggable:** Clear data flow and logging

### 4. **Business Benefits**

- **Higher Engagement:** Users stay logged in across platforms
- **Better Analytics:** Unified user tracking
- **Reduced Support:** Fewer login-related issues
- **Competitive Advantage:** Superior user experience

## 🔍 Deep Dive: How Each Component Works

### 1. **Chrome Storage API Integration**

```typescript
// Why Chrome Storage over localStorage?
// ✅ Persists across browser sessions
// ✅ Accessible from all extension contexts
// ✅ Automatic sync across devices (with sync storage)
// ✅ Quota management built-in

class StorageManager {
  // Local storage for immediate access
  static async setLocal(key: string, value: any) {
    await chrome.storage.local.set({ [key]: value });
  }

  // Sync storage for cross-device sync
  static async setSync(key: string, value: any) {
    await chrome.storage.sync.set({ [key]: value });
  }

  // Listen for changes across all contexts
  static onChange(callback: (changes: any) => void) {
    chrome.storage.onChanged.addListener(callback);
    return () => chrome.storage.onChanged.removeListener(callback);
  }
}
```

### 2. **Content Script Communication**

```typescript
// Content scripts run in web page context
// They can access both page DOM and extension APIs

class ContentScriptBridge {
  constructor() {
    this.setupPageMonitoring();
    this.setupExtensionCommunication();
  }

  setupPageMonitoring() {
    // Inject script into page context
    const script = document.createElement("script");
    script.textContent = `
      // Monitor auth-related activities
      const originalFetch = window.fetch;
      window.fetch = function(...args) {
        const promise = originalFetch.apply(this, args);
        if (args[0].includes('/auth/')) {
          promise.then(() => {
            window.dispatchEvent(new CustomEvent('auth-change'));
          });
        }
        return promise;
      };
    `;
    document.head.appendChild(script);
  }

  setupExtensionCommunication() {
    // Bridge between page and extension
    window.addEventListener("auth-change", () => {
      chrome.runtime.sendMessage({ type: "AUTH_DETECTED" });
    });
  }
}
```

### 3. **Background Script Orchestration**

```typescript
// Background scripts are the "brain" of the extension
// They coordinate between all other components

class BackgroundOrchestrator {
  constructor() {
    this.initializeSync();
    this.setupMessageHandling();
    this.schedulePeriodicSync();
  }

  async initializeSync() {
    // Sync on extension startup
    await AuthSync.syncWithServer();
  }

  setupMessageHandling() {
    // Central message router
    chrome.runtime.onMessage.addListener(
      async (message, sender, sendResponse) => {
        const handlers = {
          AUTH_DETECTED: () => this.handleAuthDetected(),
          SYNC_REQUEST: () => this.handleSyncRequest(),
          LOGOUT_REQUEST: () => this.handleLogoutRequest(),
        };

        const handler = handlers[message.type];
        if (handler) {
          const result = await handler();
          sendResponse(result);
        }
      }
    );
  }

  schedulePeriodicSync() {
    // Ensure consistency with periodic checks
    setInterval(() => {
      AuthSync.syncWithServer();
    }, 5 * 60 * 1000); // Every 5 minutes
  }
}
```

## 🔄 Alternative Approaches Comparison

### 1. **WebSocket-Based Real-Time Sync**

```typescript
// Implementation
class WebSocketSync {
  constructor() {
    this.ws = new WebSocket("wss://api.example.com/auth-sync");
    this.ws.onmessage = this.handleMessage.bind(this);
  }

  handleMessage(event) {
    const { type, data } = JSON.parse(event.data);
    if (type === "AUTH_STATE_CHANGED") {
      this.updateLocalState(data);
    }
  }
}
```

**Pros:**

- ✅ Instant real-time updates
- ✅ Server can push updates to all clients
- ✅ Efficient for high-frequency changes

**Cons:**

- ❌ Requires WebSocket server infrastructure
- ❌ Connection management complexity
- ❌ Higher resource usage
- ❌ Firewall/proxy issues

### 2. **Shared Cookie Domain Approach**

```typescript
// Implementation
class CookieSync {
  static setAuthCookie(token: string) {
    document.cookie = `auth_token=${token}; domain=.example.com; path=/`;
  }

  static getAuthCookie() {
    return document.cookie
      .split("; ")
      .find((row) => row.startsWith("auth_token="))
      ?.split("=")[1];
  }
}
```

**Pros:**

- ✅ Simple implementation
- ✅ Browser handles sync automatically
- ✅ Works across subdomains

**Cons:**

- ❌ Requires same domain/subdomain
- ❌ Limited to web contexts only
- ❌ Cookie size limitations
- ❌ Security concerns with client-side cookies

### 3. **Server-Side Session Polling**

```typescript
// Implementation
class PollingSync {
  constructor() {
    this.startPolling();
  }

  async startPolling() {
    setInterval(async () => {
      const response = await fetch("/api/auth/status");
      const { isAuthenticated, user } = await response.json();
      this.updateLocalState({ isAuthenticated, user });
    }, 30000); // Every 30 seconds
  }
}
```

**Pros:**

- ✅ Simple to implement
- ✅ Always accurate server state
- ✅ Works with any client type

**Cons:**

- ❌ High server load with many clients
- ❌ Delayed updates (polling interval)
- ❌ Unnecessary requests when no changes
- ❌ Battery drain on mobile

### 4. **Local Storage + Broadcast Channel**

```typescript
// Implementation
class BroadcastSync {
  constructor() {
    this.channel = new BroadcastChannel("auth-sync");
    this.channel.onmessage = this.handleMessage.bind(this);
  }

  notifyAuthChange(data: any) {
    localStorage.setItem("auth_state", JSON.stringify(data));
    this.channel.postMessage({ type: "AUTH_CHANGED", data });
  }

  handleMessage(event) {
    if (event.data.type === "AUTH_CHANGED") {
      this.updateUI(event.data.data);
    }
  }
}
```

**Pros:**

- ✅ Fast cross-tab communication
- ✅ No server requests needed
- ✅ Works offline

**Cons:**

- ❌ Limited to same origin
- ❌ No persistence across browser restarts
- ❌ Extension can't access web app localStorage
- ❌ Limited browser support

### 5. **Database Change Streams**

```typescript
// Implementation (MongoDB example)
class ChangeStreamSync {
  constructor() {
    this.watchAuthChanges();
  }

  async watchAuthChanges() {
    const changeStream = db.collection("sessions").watch();

    changeStream.on("change", (change) => {
      if (change.operationType === "insert") {
        this.notifyClients("USER_LOGGED_IN", change.fullDocument);
      } else if (change.operationType === "delete") {
        this.notifyClients("USER_LOGGED_OUT", change.documentKey);
      }
    });
  }
}
```

**Pros:**

- ✅ Real-time database-driven updates
- ✅ Highly accurate and consistent
- ✅ Scales well with multiple services

**Cons:**

- ❌ Requires database with change streams
- ❌ Complex infrastructure setup
- ❌ Database-specific implementation
- ❌ Higher operational complexity

## 📊 Approach Comparison Matrix

| Approach          | Real-Time  | Offline Support | Complexity | Scalability | Resource Usage |
| ----------------- | ---------- | --------------- | ---------- | ----------- | -------------- |
| **My Solution**   | ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐      | ⭐⭐⭐     | ⭐⭐⭐⭐    | ⭐⭐⭐⭐       |
| WebSocket         | ⭐⭐⭐⭐⭐ | ⭐⭐            | ⭐⭐       | ⭐⭐⭐      | ⭐⭐           |
| Shared Cookies    | ⭐⭐⭐     | ⭐⭐⭐          | ⭐⭐⭐⭐⭐ | ⭐⭐        | ⭐⭐⭐⭐⭐     |
| Server Polling    | ⭐⭐       | ⭐              | ⭐⭐⭐⭐   | ⭐⭐        | ⭐⭐           |
| Broadcast Channel | ⭐⭐⭐⭐⭐ | ⭐              | ⭐⭐⭐⭐   | ⭐⭐        | ⭐⭐⭐⭐⭐     |
| Change Streams    | ⭐⭐⭐⭐⭐ | ⭐⭐            | ⭐         | ⭐⭐⭐⭐⭐  | ⭐⭐⭐         |

## 🎯 Why My Approach Wins

### **Perfect Balance**

My solution strikes the optimal balance between:

- **Performance** vs **Resource Usage**
- **Real-time Updates** vs **Reliability**
- **Complexity** vs **Maintainability**
- **Features** vs **Simplicity**

### **Production Ready**

- ✅ Handles network failures gracefully
- ✅ Works offline and online
- ✅ Scales with user growth
- ✅ Easy to debug and monitor
- ✅ Secure by design

### **Developer Friendly**

- ✅ Clear separation of concerns
- ✅ Easy to test each component
- ✅ Well-documented APIs
- ✅ Minimal external dependencies

## 📋 Implementation Checklist

### Phase 1: Setup (Day 1)

- [ ] Configure server CORS settings
- [ ] Set up extension permissions
- [ ] Create basic auth clients

### Phase 2: Core Sync (Day 2-3)

- [ ] Implement Chrome storage wrapper
- [ ] Create auth sync manager
- [ ] Build background script orchestrator

### Phase 3: Communication (Day 4-5)

- [ ] Develop content script bridge
- [ ] Implement web app sync utility
- [ ] Create event-based communication

### Phase 4: UI Integration (Day 6-7)

- [ ] Build React hooks for both platforms
- [ ] Create auth forms and user profiles
- [ ] Add sync status indicators

### Phase 5: Testing & Polish (Day 8-10)

- [ ] Test all sync scenarios
- [ ] Add error handling
- [ ] Optimize performance
- [ ] Write documentation

## 🎉 Summary

### **What You Get**

A robust, scalable authentication synchronization system that provides seamless user experience across web app and browser extension with minimal complexity and maximum reliability.

### **Key Innovations**

1. **Multi-layer sync strategy** ensures reliability
2. **Event-driven architecture** enables loose coupling
3. **Chrome storage integration** provides offline support
4. **Content script bridge** enables real-time communication

### **Business Impact**

- **Improved User Experience:** Seamless authentication flow
- **Higher Engagement:** Users stay logged in across platforms
- **Reduced Support Costs:** Fewer authentication issues
- **Competitive Advantage:** Superior cross-platform integration

### **Technical Excellence**

- **Maintainable:** Clean, modular architecture
- **Scalable:** Easy to extend to new platforms
- **Reliable:** Multiple fallback mechanisms
- **Secure:** Proper token handling and CORS configuration

This architecture guide provides you with everything needed to recreate this system from scratch, understand the design decisions, and potentially improve upon it for your specific needs.
